import os
from pymongo import MongoClient
import requests
from dotenv import load_dotenv
from bpm.bambuconfig import BambuConfig
from bpm.bambuprinter import BambuPrinter
from bpm.bambutools import PrinterState, parseStage, parseFan
import json
import time
import signal
import sys
import threading
import email_send
from flask import Flask, jsonify, render_template, request
import os
from flask_cors import CORS
import atexit

# Load environment variables
load_dotenv()

# Logging
import logging

# Configure logging
logging.basicConfig(filename='2app.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

logging.info("Starting the application...")

# Connect to MongoDB
mongo_uri = os.getenv('MONGO_URI')
client = MongoClient(mongo_uri)
db = client['bambu_dashboard']

# Create collections
smtp_config = db['smtp_credentials']
printer_list = db['printers']
motor_endpoints = db['motor_endpoints']
global printers_json # This is the json list that is used to store the printer data
printers_json = {}

global printer_status
printer_status = {}

global last_poop_request
last_poop_request = {}

app = Flask(__name__)
CORS(app)




# Initialize collections if they don't exist
if 'smtp_credentials' not in db.list_collection_names():
    smtp_config.insert_one({
        "smtpserver": "",
        "smtpport": "",
        "smtpuser": "",
        "smtppass": "",
        "sendfrom": "",
        "sendto": ""
    })

if 'printers' not in db.list_collection_names():
    printer_list.insert_one({
        "name": "",
        "ip": "",
        "access_code": "",
        "serial_number": ""
    })

# Function to get SMTP config
def get_smtp_config():
    return smtp_config.find_one({}, {'_id': 0})

# Function to update SMTP config
def update_smtp_config(new_config):
    smtp_config.update_one({}, {"$set": new_config})

# Function to get printer list
def get_printer_list():
    return list(printer_list.find({}, {'_id': 0}))

# Function to add a printer
def add_printer(printer_data):
    printer_list.insert_one(printer_data)

# Function to update a printer
def update_printer(name, updated_data):
    printer_list.update_one({"name": name}, {"$set": updated_data})

# Function to delete a printer
def delete_printer(name):
    printer_list.delete_one({"name": name})

def get_motor_endpoints():
    return list(motor_endpoints.find({}, {'_id': 0}))

# -------------------------------------------------------------------------------------------------

# This is the main function that will be hosting the API route which will server the /printer_status route. It will also be checking for the printer extruder status and hit other endpoints.




def update_printer_status(name, status):
    global printer_status
    printer_status[name] = status
    
    
def poopGenerated(printer):
    global last_poop_request
    current_time = time.time()

    print(f"Poop Generated by {printer.name}")

    for motor in get_motor_endpoints():
        affected_printers = motor['printer_name'].split(",")
        if printer.name in affected_printers:
            # Check if a minute has passed since the last request for this printer
            if printer.name not in last_poop_request or current_time - last_poop_request[printer.name] >= 60:
                try:
                    print(f"Notifying endpoint {motor['endpoint']} for printer {printer.name}")
                    bearer = motor['access_code'].split(",")[2]
                    headers = {"Authorization": f"Bearer {bearer}"}
                    response = requests.post(motor['endpoint'], json={  
                        "seconds": 60,
                        "speed": 100,
                        "direction": int(motor['access_code'].split(",")[0])
                    }, headers=headers, timeout=5)
                    if response.status_code == 200:
                        print(f"Successfully notified endpoint {motor['endpoint']} for printer {printer.name}")
                        # Update the last request time for this printer
                        last_poop_request[printer.name] = current_time
                    else:
                        print(f"Failed to notify endpoint {motor['endpoint']} for printer {printer.name}. Status code: {response.status_code}")
                except requests.RequestException as e:
                    print(f"Error sending request to endpoint {motor['endpoint']} for printer {printer.name}: {str(e)}")
            else:
                print(f"Skipping request for {printer.name} - less than a minute since last request")

def printerStateChange(name, old_state, new_state):
    print(f"{name} - State changed from {old_state} to {new_state}")
    if new_state == "printing":
        email_send.send_email(name, "Print Job Started")
    elif new_state == "idle":
        email_send.send_email(name, "Print Job Completed")

def format_time(minutes):
    hours = minutes // 60
    minutes = minutes % 60
    return f"{hours}h {minutes}m"

def get_stage_info(stage):
    stages = {
        -1: "Idle",
        0: "Printing",
        1: "Auto Bed Leveling",
        2: "Heatbed Preheating",
        3: "Sweeping XY Mech Mode",
        4: "Changing Filament",
        5: "M400 Pause",
        6: "Paused due to filament runout",
        7: "Heating Hotend",
        8: "Calibrating Extrusion",
        9: "Scanning Bed Surface",
        10: "Inspecting First Layer",
        11: "Identifying Build Plate Type",
        12: "Calibrating Micro Lidar",
        13: "Homing Toolhead",
        14: "Cleaning Nozzle Tip",
        15: "Checking Extruder Temperature",
        16: "Printing was paused by the user",
        17: "Pause of front cover falling",
        18: "Calibrating Micro Lidar",
        19: "Calibrating Extrusion Flow",
        20: "Paused due to nozzle temperature malfunction",
        21: "Paused due to heat bed temperature malfunction",
        22: "Filament unloading",
        23: "Skip step pause",
        24: "Filament loading",
        25: "Motor noise calibration",
        26: "Paused due to AMS lost",
        27: "Paused due to low speed of the heat break fan",
        28: "Paused due to chamber temperature control error",
        29: "Cooling chamber",
        30: "Paused by the Gcode inserted by user",
        31: "Motor noise showoff",
        32: "Nozzle filament covered detected pause",
        33: "Cutter error pause",
        34: "First layer error pause",
        35: "Nozzle clog pause",
        255: "Printer is idle"
    }
    return stages.get(stage, "Unknown stage")


def create_printer(ip, access_code, serial_number, printer_name):
    config = BambuConfig(hostname=ip, access_code=access_code, serial_number=serial_number)
    printer = BambuPrinter(config=config)
    printer.name = printer_name
    return printer

def monitor_printer(printer):
    printer.start_session()
    
    # Wait for the printer to connect and receive initial data
    time.sleep(3)
    
    # Print current printer status
    update_printer_status(printer.name, is_printer_idle(printer))
    active_printers = ", ".join([p.name for p in printers])
    print(f"Active Printers: {active_printers}")

    old_state = "idle" if is_printer_idle(printer) else "printing"
    previous_state = {}
    
    # Initialize previous_state with the initial printer status
    printer_status[printer.name] = {
        "stage": get_stage_info(printer._current_stage),
        "progress": f"{printer.percent_complete}%",
        "time_remaining": format_time(printer.time_remaining),
        "current_state": old_state
    }
    
    # Serialize the initial printer object to JSON and store in 'doc'
    printer_json_str = json.dumps(printer, default=printer.jsonSerializer, indent=4, sort_keys=True)
    printer_status[printer.name]["doc"] = json.loads(printer_json_str)
    
    previous_state = printer_status[printer.name].copy()

    while True:
        current_state = "idle" if is_printer_idle(printer) else "printing"

        # Update printer_status with current information
        printer_status[printer.name] = {
            "stage": get_stage_info(printer._current_stage),
            "progress": f"{printer.percent_complete}%",
            "time_remaining": format_time(printer.time_remaining),
            "current_state": current_state
        }
        
        # Serialize the printer object to JSON and then parse it back to a dictionary
        printer_json_str = json.dumps(printer, default=printer.jsonSerializer, indent=4, sort_keys=True)
        printer_status[printer.name]["doc"] = json.loads(printer_json_str)

        if current_state != old_state:
            printerStateChange(printer.name, old_state, current_state)
            old_state = current_state
        
        # ---------------------------
        if printer.name == "EXONMAKE B06":
            # Compute the differences between current_state and previous_state
            changes = get_dict_diff(previous_state, printer_status[printer.name])
            if changes:
                print(f"Changes for {printer.name}: {json.dumps(changes, indent=4)}")
            # Update previous_state with the current state
            previous_state = printer_status[printer.name].copy()
        # ---------------------------
        
        if current_state == "printing" and printer._gcode_state != "IDLE":
            if printer._spool_state == "Loading":
                poopGenerated(printer)
            if printer._current_stage == 14:
                poopGenerated(printer)

            """
            doc._ams_status
            doc._spool_state (Unloading, Loading, Loaded)
            """   
            #print(f"{printer.name} - Print Progress: {printer.percent_complete}% | Current Stage: {get_stage_info(printer._current_stage)}")
        
        else:
            #print(f"{printer.name} - Printer is idle")
            pass
        time.sleep(1)
    
    # Print complete
    print(f"{printer.name} - Print job finished!")
    
    # Serialize printer state to JSON
    printer_json = json.dumps(printer, default=printer.jsonSerializer, indent=4, sort_keys=True)
    print(f"{printer.name} - Printer State JSON:")
    #print(printer_json)

    # End the session
    printer.quit()

def get_dict_diff(old, new, path=""):
    """
    Recursively find differences between two dictionaries.
    Returns a dictionary with the changed keys and their new values.
    """
    diffs = {}
    for key in new:
        if key not in old:
            diffs[path + key] = new[key]
        else:
            if isinstance(new[key], dict) and isinstance(old[key], dict):
                nested_diff = get_dict_diff(old[key], new[key], path + key + ".")
                diffs.update(nested_diff)
            elif new[key] != old[key]:
                diffs[path + key] = new[key]
    return diffs

def is_printer_idle(printer):
    gcode_state = printer._gcode_state
    print_type = printer._print_type
    current_stage = printer._current_stage
    #print(f"{printer.name} - Gcode State: {gcode_state} | Print Type: {print_type} | Current Stage: {current_stage}")
    if gcode_state == "FINISH" and print_type == "idle" and current_stage == 255:
        return True
    else:
        return False

printers = []

def signal_handler(sig, frame):
    print("Keyboard interrupt received. Closing all sessions...")
    global printers
    for printer in printers:
        printer.quit()
    sys.exit(0)

def check_MQTT_connection(ip, access_code, serial_number):
    try:
        config = BambuConfig(hostname=ip, access_code=access_code, serial_number=serial_number)
        printer = BambuPrinter(config=config)
        printer.start_session()
        return True
    except Exception as e:
        print(f"Error checking MQTT connection: {e}")
        return False

@app.route('/api/printer_status', methods=['GET'])
def printer_status():
    global printer_status
    return jsonify(printer_status)

@app.route('/api/shutdown', methods=['POST'])
def shutdown():
    shutdown_server()
    return 'Server shutting down...'

def shutdown_server():
    print("Shutting down server...")
    # Perform cleanup tasks
    for printer in printers:
        printer.quit()
    # Stop the Flask server
    os._exit(0)

def cleanup():
    print("Performing cleanup...")
    for printer in printers:
        printer.quit()

atexit.register(cleanup)

def start_flask_thread():
    app.run(host='0.0.0.0', port=3434)


def main():
    email_send.send_email("3D Printer Server Side", "Server Started")

    global printers
    # Example usage
    

    # Set up signal handler for keyboard interrupt
    signal.signal(signal.SIGINT, signal_handler)
    
    # Init Each Printer Status
    global printer_status
    printer_status = {}

    # Monitor printers using threading
    threads = []

    printer_list = get_printer_list()
    #print(printer_list)

    printers = []
    for printer_obj in printer_list:
        print(printer_obj)
        print(f"Creating printer: {printer_obj['name']}")
        printer = create_printer(
            printer_obj['ip'],
            printer_obj['access_code'],
            printer_obj['serial_number'],
            printer_obj['name']
        )
        thread = threading.Thread(target=monitor_printer, args=(printer,))
        thread.daemon = True  # Set threads as daemon so they exit when main thread exits
        thread.start()
        threads.append(thread)
    
    # Start the Flask thread
    flask_thread = threading.Thread(target=start_flask_thread)
    flask_thread.daemon = True
    flask_thread.start()

    
    try:
        # Wait for all threads to complete
        while any(thread.is_alive() for thread in threads):
            time.sleep(1)
    except KeyboardInterrupt:
        print("Keyboard interrupt received in main thread. Waiting for threads to finish...")
        # The signal_handler will handle closing the sessions
    # monitor_printer(printer_b06)

# Add the /printer_status route



if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("Keyboard interrupt received. Shutting down...")
    finally:
        cleanup()